#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass extarticle
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement ph
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Analysis on Methods: Root Finding and Interpolation
\end_layout

\begin_layout Author
Seth Shelnutt
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
Numerical Analysis, it is defined as 
\begin_inset Quotes eld
\end_inset

The branch of mathematics that deals with the development and use of numerical
 methods for solving problems
\begin_inset Quotes erd
\end_inset

.
 Since before the Greeks man has often sought to put some physical process
 or data into a mathematical representation.
 Since the shift into the modern atomic era this field of mathematics has
 become ever more important as computers are able to perform these numerical
 methods at levels never before seen.
 Two topics of this field are root finding and interpolation.
 Various methods of these topics will be examined and tested for accuracy
 and speed, with a focus on proper statistical analysis.
 
\end_layout

\begin_layout Abstract
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Paragraph*
When implementing the field of numerical analysis there are several factors
 to first consider.
 The very first question to answer is will this be done by hand or on a
 computer? This has a large impact on what methods can be considered to
 evaluate the problems.
 In this case a computer will be used.
 This thing brings up the question of what language to use for this analysis.
 There are three main languages which are considered standard.
 First for cases which require the most optimization and speed C is used.
 For a easy to use high level 
\begin_inset Quotes eld
\end_inset

language
\begin_inset Quotes erd
\end_inset

 matlab is often chosen.
 The problem with matlab is two fold, first it is commercial and only available
 on certain platforms.
 Second is that it's less of a language and more of an interactive terminal,
 thus making complex programming difficult.
 
\end_layout

\begin_layout Paragraph*
In the middle ground between these two languages lies Python.
 Python offers the robust mathematical support of matlab through numeric
 python (numpy), scientific python (scipy) and symbolic python (sympy).
 With the extension of Matplotlib, python also offers a diverse graphical
 package.
 Python is a higher level language than C, and offers many features such
 as garbage collecting and memory allocation.
 Code is run inside an interpreter which means it can be run on any platform
 python is support.
 By the open source nature of python, nearly any existing platform, be it
 mainstream or embedded is supported.
 Python also offers various methods of optimization, be it in the code,
 or the interpreter.
 Python also offers support for inline C code if needed.
 Overall python's rugged and robust offerings make it the ideal language
 for numerical analysis and thus will be used in this paper.
\end_layout

\begin_layout Section
Root Finding
\end_layout

\begin_layout Paragraph*
For the purpose of this section the object is to find the intersection of
 
\begin_inset Formula $e^{\frac{-x}{5}}$
\end_inset

 and 
\begin_inset Formula $\sin x$
\end_inset

.
 That is the roots of 
\begin_inset Formula $e^{\frac{-x}{5}}=\sin x$
\end_inset

 .
\end_layout

\begin_layout Subsection
Visual Inspection
\end_layout

\begin_layout Paragraph*
The first and simplest method for root finding is a visual inspection.
 With a visual inspection a graph is shown and a user selects an x value
 that is approximately a zero.
 Here matplotlib is used to create the graph of the two functions and the
 user is asked to click on the point in which the zero is approximated.
 From this the x value is given and the difference in 
\begin_inset Formula $e^{\frac{-x}{5}}$
\end_inset

 - 
\begin_inset Formula $\sin x$
\end_inset

.
 See Figure 1.
 
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "50text%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Graphics
	filename Visual.png
	display false
	scale 40

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph*
Here the first of the four intersections is estimated to be, 
\begin_inset Formula $x=0.967742$
\end_inset

 and the difference between the two functions is: -0.000422834187542 .
 So depending on the interval and scale one can guess reasonably close,
 however the chances of visually selecting the intersection with a high
 degree of precision is unlikely.
 The remaining estimates on the intersections are at 
\begin_inset Formula $x=\left\{ 2.479839,6.572581,9.274194\right\} $
\end_inset

and the differences between the functions were 0.00552022494328 , 0.016768497586
 and -0.00646222207318.
 By and large in most cases a higher degree of accuracy is sought after.
 Thus a more mathematical process such as bisection or Newton's method is
 to be examined.
\end_layout

\begin_layout Subsection
Bisection
\end_layout

\begin_layout Paragraph
The bisection method stems from bisecting an interval in each iteration.
 A function and an interval is given.
 The interval is then bisected and a sign change is looked for on either
 side of midpoint.
 On the side that there is a sign change a new interval is formed between
 that end point and the midpoint.
 This then forms a new interval in which the next iteration takes place
 on.
 Mathematically we are doing: Given a bound 
\begin_inset Formula $\left[x_{1},x_{2}\right]$
\end_inset

, 
\begin_inset Formula $x_{3}=\frac{x_{1}+x_{2}}{2}$
\end_inset

, 
\begin_inset Formula $f(x_{1})f(x_{3})\begin{cases}
<0 & x_{2}=x_{3}\\
>0 & x_{1}=x_{3}\\
=0 & f(x_{3})=0
\end{cases}$
\end_inset

.
 
\end_layout

\begin_layout Paragraph
Now that a formula is established there are two lingering questions.
 What is the convergence rate and what is error in this method? The maximum
 error is given by 
\begin_inset Formula $\frac{\Vert b-a\Vert}{2^{i}}$
\end_inset

, where i is the number of iterations run.
 This yields the convergence rate of 
\begin_inset Formula $\frac{b-a}{2^{i}}$
\end_inset

, or simply 
\begin_inset Formula $\frac{1}{2}$
\end_inset

.
 This resultant linear convergence is good, but when finding the zero of
 
\begin_inset Formula $e^{\frac{-x}{5}}=\sin x$
\end_inset

 , between 0 and 2 with python it takes 21 iterations and 0.000659 seconds.
 The zero is estimated by 
\begin_inset Formula $x=0.968319892883$
\end_inset

 While in this small instance that does not seem like a significant amount,
 on larger and more complex systems this could end up taking significant
 time and number of iterations.
 A quadratic approach was developed by Newton to quicken root finding and
 will be discussed in the next section.
\end_layout

\begin_layout Subsection
Newton's Method
\end_layout

\begin_layout Paragraph
Newton first developed his method for root finding in De analysi per aequationes
 numero terminorum infinitas written in 1669 and in De metodis fluxionum
 et serierum infinitarum written in 1671.
 Both of these description vary from the modern Newton's method as Newton
 failed to make the connection to Calculus and instead is based on a pure
 algebraic implementation.
 The modern interpetation of Newton's method and the one implemented in
 this project is 
\begin_inset Formula $x_{n+1}=x_{n}+\frac{f(x_{n})}{f'(x_{n})}$
\end_inset

 where you test for 
\begin_inset Formula $f(x_{n+1})=0$
\end_inset

.
 Here as with the bisection the function the zero is being determined is
 
\begin_inset Formula $e^{\frac{-x}{5}}-\sin x=0$
\end_inset

.
 The convergence of Newton's method is what gives it an advange over the
 bisection method.
 The convergence is given by 
\begin_inset Formula $lim\limits _{n\rightarrow\text{âˆž}}\frac{x_{n+1}-\alpha}{(x_{n}-\alpha)^{2}}=\frac{f^{2}(a)}{2}$
\end_inset

.
 Thus Newton's method yield quadratic convergence on the root.
\end_layout

\begin_layout Paragraph
When implementing Newton's method in python intriquing results are found.
 Starting at the same initial point as in bisection, 
\begin_inset Formula $x_{1}=0$
\end_inset

, it takes only 4 iterations to find the zero at 
\begin_inset Formula $x=0.968319798371$
\end_inset

.
 How it takes 0.1072 seconds to calculate this.
 This is an astonishing 162 times longer than the bisection method.
 Even though the number of iteration was decreased by over 80% the time
 it takes to calculate the derivative yields in a more timely process.
\end_layout

\end_body
\end_document
