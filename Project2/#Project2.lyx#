#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass extarticle
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement ph
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Analysis on Methods: Numerical Integration and ODE
\end_layout

\begin_layout Author
Seth Shelnutt
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
Numerical Analysis, it is defined as 
\begin_inset Quotes eld
\end_inset

The branch of mathematics that deals with the development and use of numerical
 methods for solving problems
\begin_inset Quotes erd
\end_inset

.
 As we have advanced into the modern age enginerring problems are become
 increasing complex.
 With this a turn to computer simulation to aid in development and problem
 solving.
 In these cases two topics of the numerical analysis field are most often
 sought and used.
 Numerical integration and numerical solutions to ordinary differential
 equations are two topics which come up often in simulating engineering
 systems.
 Various methods of these topics will be examined and tested for accuracy
 and speed.
\end_layout

\begin_layout Abstract
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Abstract
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Paragraph*
When implementing the field of numerical analysis there are several factors
 to first consider.
 Most of the factors are inherited from what type of problem is being analysised
 and solved.
 In this case study numerical integration and oridinary differnetial equations
 is the target.
 As in the last paper on numerical analysis, the choosen language for this
 work is Python.
 Python lies in a middle ground between straight C and using matlab, which
 are the two common techniques.
 Python offers the robust mathematical support of matlab through numeric
 python (numpy), scientific python (scipy) and symbolic python (sympy).
 With the extension of Matplotlib, python also offers a diverse graphical
 package.
 Python is a higher level language than C, and offers many features such
 as garbage collecting and memory allocation.
 Code is run inside an interpreter which means it can be run on any platform
 python is support.
 By the open source nature of python, nearly any existing platform, be it
 mainstream or embedded is supported.
 Python also offers various methods of optimization, be it in the code,
 or the interpreter.
 Python also offers support for inline C code if needed.
 Overall python's rugged and robust offerings make it the ideal language
 for numerical analysis and thus will be used in this paper.
\end_layout

\begin_layout Section
Numerical Integration
\end_layout

\begin_layout Paragraph*
For the purpose of this section the object is to find the integral of 
\begin_inset Formula $\intop_{0}^{4}f(x)dx$
\end_inset

, where 
\begin_inset Formula $f(x)=e^{3x}$
\end_inset

and 
\begin_inset Formula $f(x)=1+\sin(10\pi x)$
\end_inset

.
\end_layout

\begin_layout Subsection
Riemann Sums
\end_layout

\begin_layout Paragraph*
The first and simplest method for root finding is a visual inspection.
 With a visual inspection a graph is shown and a user selects an x value
 that is approximately a zero.
 Here matplotlib is used to create the graph of the two functions and the
 user is asked to click on the point in which the zero is approximated.
 From this the x value is given and the difference in 
\begin_inset Formula $e^{\frac{-x}{5}}$
\end_inset

 - 
\begin_inset Formula $\sin x$
\end_inset

.
 See Figure 1.
 
\end_layout

\begin_layout Paragraph*
Here the first of the four intersections is estimated to be, 
\begin_inset Formula $x=0.967742$
\end_inset

 and the difference between the two functions is: -0.000422834187542 .
 So depending on the interval and scale one can guess reasonably close,
 however the chances of visually selecting the intersection with a high
 degree of precision is unlikely.
 The remaining estimates on the intersections are at 
\begin_inset Formula $x=\left\{ 2.479839,6.572581,9.274194\right\} $
\end_inset

and the differences between the functions were 0.00552022494328 , 0.016768497586
 and -0.00646222207318.
 By and large in most cases a higher degree of accuracy is sought after.
 Thus a more mathematical process such as bisection or Newton's method is
 to be examined.
\end_layout

\begin_layout Subsection
Trapezoid Rule
\end_layout

\begin_layout Paragraph
The bisection method stems from bisecting an interval in each iteration.
 A function and an interval is given.
 The interval is then bisected and a sign change is looked for on either
 side of midpoint.
 On the side that there is a sign change a new interval is formed between
 that end point and the midpoint.
 This then forms a new interval in which the next iteration takes place
 on.
 Mathematically we are doing: Given a bound 
\begin_inset Formula $\left[x_{1},x_{2}\right]$
\end_inset

, 
\begin_inset Formula $x_{3}=\frac{x_{1}+x_{2}}{2}$
\end_inset

, 
\begin_inset Formula $f(x_{1})f(x_{3})\begin{cases}
<0 & x_{2}=x_{3}\\
>0 & x_{1}=x_{3}\\
=0 & f(x_{3})=0
\end{cases}$
\end_inset

.
 
\end_layout

\begin_layout Paragraph
Now that a formula is established there are two lingering questions.
 What is the convergence rate and what is error in this method? The maximum
 error is given by 
\begin_inset Formula $\frac{\Vert b-a\Vert}{2^{i}}$
\end_inset

, where i is the number of iterations run.
 This yields the convergence rate of 
\begin_inset Formula $\frac{b-a}{2^{i}}$
\end_inset

, or simply 
\begin_inset Formula $\frac{1}{2}$
\end_inset

.
 This resultant linear convergence is good, but when finding the zero of
 
\begin_inset Formula $e^{\frac{-x}{5}}=\sin x$
\end_inset

 , between 0 and 2 with python it takes 21 iterations and 0.000659 seconds.
 The zero is estimated by 
\begin_inset Formula $x=0.968319892883$
\end_inset

 While in this small instance that does not seem like a significant amount,
 on larger and more complex systems this could end up taking significant
 time and number of iterations.
 A quadratic approach was developed by Newton to quicken root finding and
 will be discussed in the next section.
\end_layout

\begin_layout Subsection
Simpson’s Rule
\end_layout

\begin_layout Paragraph
Newton first developed his method for root finding in De analysi per aequationes
 numero terminorum infinitas written in 1669 and in De metodis fluxionum
 et serierum infinitarum written in 1671.
 Both of these description vary from the modern Newton's method as Newton
 failed to make the connection to Calculus and instead is based on a pure
 algebraic implementation.
 The modern interpretation of Newton's method and the one implemented in
 this project is 
\begin_inset Formula $x_{n+1}=x_{n}-\frac{f(x_{n})}{f'(x_{n})}$
\end_inset

 where you test for 
\begin_inset Formula $f(x_{n+1})=0$
\end_inset

.
 Here as with the bisection the function the zero is being determined is
 
\begin_inset Formula $e^{\frac{-x}{5}}-\sin x=0$
\end_inset

.
 The convergence of Newton's method is what gives it an advantage over the
 bisection method.
 The convergence is given by 
\begin_inset Formula $lim_{n\rightarrow\text{∞}}\frac{x_{n+1}-\alpha}{(x_{n}-\alpha)^{2}}=\frac{f^{2}(a)}{2}$
\end_inset

.
 Thus Newton's method yield quadratic convergence on the root.
\end_layout

\begin_layout Paragraph
When implementing Newton's method in python intriguing results are found.
 Starting at the same initial point as in bisection, 
\begin_inset Formula $x_{1}=0$
\end_inset

, it takes only 4 iterations to find the zero at 
\begin_inset Formula $x=0.968319798371$
\end_inset

.
 How it takes 0.1072 seconds to calculate this.
 This is an astonishing 162 times longer than the bisection method.
 Even though the number of iteration was decreased by over 80% the time
 it takes to calculate the derivative yields in a more timely process.
 The the optimization section a more detailed analysis of this time differential
 and methods to improve speed will be examined.
\end_layout

\begin_layout Subsection
Comparision
\end_layout

\begin_layout Paragraph
Alala
\end_layout

\begin_layout Section
Numerical ODE Solving Routines
\end_layout

\begin_layout Paragraph
Ordinary Differential Equations have vast applications in physics and engineerin
g where they model various systems.
 Solving these numerically allows the said system to be modeled dynamically
 and on a computer.
 When solving odes it is important to remember that each method does not
 yield an interpolated function, instead it only gives the estimated y-value
 for each 
\begin_inset Formula $x+n*h$
\end_inset

 coordinate.
 The first ode to solve for is 
\begin_inset Formula $y'=3y$
\end_inset

 with an initial value of 
\begin_inset Formula $y(0)=1$
\end_inset

 over the range 
\begin_inset Formula $\left[0,3\right]$
\end_inset

.
 The second ODE is 
\begin_inset Formula $y'=\frac{1}{1+x^{2}}-2y^{2}$
\end_inset

 with an initial value of 
\begin_inset Formula $y(0)=0$
\end_inset

 over the range 
\begin_inset Formula $\left[0,10\right]$
\end_inset

.
 Each of these ordinary differential equations will be examined with four
 step sizes, 0.1, 0.05, 0.01, 0.005.
\end_layout

\begin_layout Subsection
Euler’s Method
\end_layout

\begin_layout Paragraph
Euler published his method for solving odes in 1768.
 The general method is given by 
\begin_inset Formula $y_{n+1}=y_{n}+h*f(x_{n},y_{n})$
\end_inset

, where 
\begin_inset Formula $y'=f(x,y)$
\end_inset

.
 As with each method of numerical ode solution methods this is an iterative
 process.
 In order to map out the solution each x and y coordinate are stored in
 a list and then draw on the graph.
 
\end_layout

\begin_layout Paragraph
As always when estimatation is used, the error value is important.
 How good and how close is our estimations? For the purposes of this paper
 the maximum error given by 
\begin_inset Formula $|f(x_{n})-y_{n}|$
\end_inset

 will be used.
\end_layout

\begin_layout Paragraph
For the function 
\begin_inset Formula $y'=3y$
\end_inset

 over the range 
\begin_inset Formula $\left[0,3\right]$
\end_inset

 and intial value 
\begin_inset Formula $y(0)=1$
\end_inset

, four separate step values will be examined.
 First with a step size of h=0.1, then h=0.05, next h=0.01 and lastly h=0.005.
 See figure 1 for a graph showing all four step size.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Graphics
	filename Euler-all-f1.png
	display false
	scale 42

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
When h = 0.1, the maximum error is calculated to be 5483.09.
 It took a meer 0.00006 seconds to calculate this.
 When the step size is decreased to h=0.05, it can be seen that there is
 an exponential growth in the time taken to calculate it.
 0.00037 seconds.
 The error has drastically decreased to 3719.1 as a result of this step size
 change.
 The additional time taken to calculate is insignificant.
 When the step size is increased to h=0.01 and then to h=0.005 the respective
 maximum errors are 1004.6 and 523.8.
 The time taken for each is 0.00039 seconds and 0.00076 seconds.
 Again the error is reduced greatly with each change in step size.
 The additional tme taken is still insignificant for the large gains in
 accuracy.
\end_layout

\begin_layout Paragraph
When examining the second initial value problem of 
\begin_inset Formula $y'=\frac{1}{1+x^{2}}-2y^{2}$
\end_inset

 over the range 
\begin_inset Formula $\left[0,10\right]$
\end_inset

 and intial value 
\begin_inset Formula $y(0)=0$
\end_inset

, four separate step values will again be examined.
 First with a step size of h=0.1, then h=0.05, next h=0.01 and lastly h=0.005.
 See figure 2 for a graph showing all step sizes.
\end_layout

\begin_layout Paragraph
When h = 0.1, the maximum error is calculated to be 0.0004.
 It took 0.00022 seconds to calculate this.
 When the step size is decreased to h=0.05, as expected the error has decreased
 to 0.0002.
 This change is error is significantly less than what was seen in the first
 ode.
 The time taken as increased to 0.00039 seconds.
 The additional time taken to calculate is insignificant.
 When the step size is decreased to h=0.01 and then to h=0.005 the respective
 maximum errors are 0.00004 and 0.00002.
 The time taken for each is 0.0019 seconds and 0.0037 seconds.
 The error continues to decrease as expected with a smaller step size.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement o
overhang 0col%
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Graphics
	filename Euler-all-f2.png
	display false
	scale 42

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Overall Euler's method appears to be fast but the accurancy decreases the
 further the iteration is taken.
 This is seen as the maximum error increases at a quadratic pace.
 The next logical step would seem to be 
\end_layout

\begin_layout Subsection
Midpoint Method
\end_layout

\begin_layout Paragraph
The general method is given by 
\begin_inset Formula $y_{n+1}=h*f((x_{n}+0.5*h),(y_{n}+0.5*h*f(x_{n},y_{n})))$
\end_inset

, where 
\begin_inset Formula $y'=f(x,y)$
\end_inset

.
 As with each method of numerical ode solution methods this is an iterative
 process.
 In order to map out the solution each x and y coordinate are stored in
 a list and then draw on the graph.
 
\end_layout

\begin_layout Paragraph
As always when estimatation is used, the error value is important.
 How good and how close is our estimations? For the purposes of this paper
 the maximum error given by 
\begin_inset Formula $|f(x_{n})-y_{n}|$
\end_inset

 will be used.
\end_layout

\begin_layout Paragraph
For the function 
\begin_inset Formula $y'=3y$
\end_inset

 over the range 
\begin_inset Formula $\left[0,3\right]$
\end_inset

 and intial value 
\begin_inset Formula $y(0)=1$
\end_inset

, four separate step values will be examined.
 As with Euler's method first with a step size of h=0.1, then h=0.05, next
 h=0.01 and lastly h=0.005 with be used.
 See figure 3 for a graph showing all four step sizes and their respective
 graphs.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Graphics
	filename midpoint-all-f1.png
	display false
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
When h = 0.1, the maximum error is calculated to be 830.8.
 It took a swift 0.00007 seconds to calculate this.
 Already this midpoint method is close to the level of accuracy which took
 the Euler's method a step size of h=0.005 to reach.
 When the step size is decreased to h=0.05, the error is now below the best
 Euler could attain at 240.9.
 The additional time taken to calculate is two magnetudes higher at 0.0013
 but remains insignificant.
 When the step size is decreased to h=0.01 the maximum error becomes 10.7,
 and again the time taken is insignificant.
 At h=0.005 the maximum error is only 2.7.
 At 2.7, nearly a 200th of what Euler's method yielded.
 The additional tme taken is still insignificant for the large gains in
 accuracy.
\end_layout

\begin_layout Paragraph
When examining the second initial value problem of 
\begin_inset Formula $y'=\frac{1}{1+x^{2}}-2y^{2}$
\end_inset

 over the range 
\begin_inset Formula $\left[0,10\right]$
\end_inset

 and intial value 
\begin_inset Formula $y(0)=0$
\end_inset

, the same four step sizes will be used and graphed in figure 4.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Graphics
	filename midpoint-all-f2.png
	display false
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
When h = 0.1, the maximum error is calculated to be 0.00007.
 It took 0.00035 seconds to calculate this.
 When the step size is decreased to h=0.05, as expected the error has decreased
 to 0.0000017.
 This change is error is significantly less than what was seen in the first
 ode.
 The time taken as increased to 0.00069 seconds.
 The additional time taken to calculate is insignificant.
 When the step size is increased to h=0.01 and then to h=0.005 the respective
 maximum errors are 
\begin_inset Formula $6.797e-8$
\end_inset

 and 
\begin_inset Formula $1.697e-8$
\end_inset

.
 The time taken for each is 0.0033 seconds and 0.0066 seconds.
 The error continues to decrease as expected with a smaller step size.
\end_layout

\begin_layout Paragraph
The accuracy of the midpoint method is vastly superior to the Euler method.
 The increase in calculation time is insignificant with respect to modern
 computing power.
 With a the relative speed and accuracy of this method it remains to be
 seen if the trapezoid method can yield any vast improvments over it.
\end_layout

\begin_layout Subsection
Trapezoid Method
\end_layout

\begin_layout Paragraph
The iterative trapezoid method is given by 
\begin_inset Formula $y_{n+1}=0.5*h*f(x_{n},y_{n})+0.5*h*f(x_{n+1},y_{n+1})$
\end_inset

, where 
\begin_inset Formula $y'=f(x,y)$
\end_inset

.
 Since 
\begin_inset Formula $y_{n+1}$
\end_inset

is on both side of the equations we can estimate 
\begin_inset Formula $y_{n+1}$
\end_inset

using euler's method, then plug our value new 
\begin_inset Formula $y_{n+1}$
\end_inset

back into the formula to obtain a better approximation.
 This yields, 
\begin_inset Formula $y_{n+1}=0.5*h*f(x_{n},y_{n})+0.5*h*f(x_{n+1},y_{n}+h*f(x_{n},y_{n}))$
\end_inset

 In order to map out the solution each x and y coordinate are stored in
 a list and then draw on the graph.
 
\end_layout

\begin_layout Paragraph
As always when estimatation is used, the error value is important.
 How good and how close is our estimations? For the purposes of this paper
 the maximum error given by 
\begin_inset Formula $|f(x_{n})-y_{n}|$
\end_inset

 will be used.
\end_layout

\begin_layout Paragraph
For the function 
\begin_inset Formula $y'=3y$
\end_inset

 over the range 
\begin_inset Formula $\left[0,3\right]$
\end_inset

 and intial value 
\begin_inset Formula $y(0)=1$
\end_inset

, four separate step values will be examined.
 As with previous methods the first step size used is h=0.1, then h=0.05,
 next h=0.01 and lastly h=0.005 with be used.
 See figure 5 for a graph showing all four step sizes and their respective
 graphs.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Graphics
	filename trapezoid-all-f1.png
	display false
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
When h = 0.1, the maximum error is calculated to be 830.8.
 This is the same level of error that the midpoint method yielded.
 It took 0.000087 seconds to calculate this, which is a little over twice
 as long as for the midpoint method.
 When the step size is decreased to h=0.05, the error remains the same as
 the midpoint method at 240.9.
 The additional time taken to calculate is higher at 0.0009 but remains insignifi
cant.
 When the step size is decreased to h=0.01 the maximum error becomes 10.7,
 and again the time taken is insignificant.
 At h=0.005 the maximum error is only 2.7.
 Both of these remain nearly exactly what the midpoint method yielded.
 The time taken to calculate each however was longer but insignificant.
\end_layout

\begin_layout Paragraph
When examining the second initial value problem of 
\begin_inset Formula $y'=\frac{1}{1+x^{2}}-2y^{2}$
\end_inset

 over the range 
\begin_inset Formula $\left[0,10\right]$
\end_inset

 and intial value 
\begin_inset Formula $y(0)=0$
\end_inset

, the same four step sizes will be used and graphed in figure 6.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Graphics
	filename trapezoid-all-f2.png
	display false
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
When h = 0.1, the maximum error is calculated to be 
\begin_inset Formula $9.307e-8$
\end_inset

.
 It took 0.00045 seconds to calculate this.
 When the step size is decreased to h=0.05, as expected the error has decreased
 to 
\begin_inset Formula $2.306e-8$
\end_inset

.
 This change is error is significantly less than what was seen in the first
 ode and remains different than the midpoint method.
 The time taken as increased to 0.00091 seconds.
 The additional time taken to calculate is insignificant.
 When the step size is increased to h=0.01 and then to h=0.005 the respective
 maximum errors are 
\begin_inset Formula $9.15e-8$
\end_inset

 and 
\begin_inset Formula $2.285e-8$
\end_inset

.
 The time taken for each is 0.004 seconds and 0.009 seconds.
 
\end_layout

\begin_layout Paragraph
We see that using this trapezoid method time it takes to calculate each
 ode at the different step sizes is longer than the time taken for midpoint.
 Although the accuracy is no better.
\end_layout

\begin_layout Subsection
Comparision
\end_layout

\begin_layout Paragraph
The three unique methods implemented in this paper for ordinary differential
 equation solving each yield different results in terms of speed an accuracy.
 Overall speed is a non-issue as each took fractions of a second to calculate.
 However in comparision to each other the time take yields clues to efficiency.
 The measure of accuracy was the maximum error, or 
\begin_inset Formula $f(x_{n})-y_{n}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Graphics
	filename f1-0.1.png
	display false
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
When looking at the error of these methods with respect to the first ode
 of 
\begin_inset Formula $y'=3*y$
\end_inset

 it can be seen quite clearly that Euler has the largest error at all step
 sizes.
 Midpoint and trapezoid method yield an error are h=0.1 which is comparable
 to the Euler error at h=0.005.
 Euler's method is magnitude of 10 slower at h=0.005 compared to midpoint
 when h=0.1.
 The midpoint method and trapezoid method is significantly more efficient
 that Euler's method.
 In figure 7 a comparision of the graphs of the three methods for h=0.1.
 
\end_layout

\begin_layout Standard
\begin_inset Wrap figure
lines 0
placement r
overhang 0in
width "50col%"
status open

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
\begin_inset Graphics
	filename f2-0.1.png
	display false
	scale 45

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
When examing the second ode of 
\begin_inset Formula $y'=\frac{1}{1+x^{2}}-2y^{2}$
\end_inset

similar results to the first ode can be seen.
 With the midpoint and trapezoid methods at h=0.1 it is comparable to the
 euler method when the stepsize is .005.
 At h=0.05 both the midpoint and trapezoid surpass the accuracy of the euler
 method at h=0.005.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Paragraph*
The goal of this paper was to implement various methods of numerical analysis.
 It sought to study the factor and difficulties in implementing these methods
 and formulas in the language of python.
 First root finding methods were studied for both speed and iterations.
 It was found that while Newton's method had the fewest iterations it took
 the most wall time to calculate based on the fact that doing numerical
 derivatives are not as fast as algebraic operations.
 The midpoint and ultimately the secant method were far quicker with this
 simple function of 
\begin_inset Formula $e^{\frac{-x}{5}}-\sin x=0$
\end_inset

.
 Thus what might take the fewest iterations or be the fastest by hand does
 not always translate to the faster method on a computer.
\end_layout

\begin_layout Paragraph*
The second field examined was interpolation.
 In the field of interpolation there are various methods that one might
 use depending on their needs.
 First Lagrange polynomials were examined and it was noticed that no only
 is there an issue with smoothness at higher orders but also with the time
 it takes to calculate these.
 Piecewise linear interpolation was found to be incredibly fast but lacking
 in smoothness and accuracy even with a high number of points.
 Raised cosine interpolation solved the smoothness issue, but results in
 a piecewise function that is continuous but not differentiable.
 
\end_layout

\begin_layout Paragraph*
Least squares approximation yields a function that is continuous and differentia
ble as Lagrange is.
 At lower degrees of order it tends to be more smooth than Lagrange is,
 but the trade off is that there is no guarantee that at the given data
 points the function will be equal.
 This is a result of the methodology which is that the squares of the sum
 of the difference from the given data points is to be zero.
 
\end_layout

\begin_layout Paragraph
In an effort to find a interpolation function which is smooth and fast,
 the Lagrange method was re-examined.
 It was determined that if the code was parallelized it could result in
 a net increase in the speed while maintaining the same level of smoothness.
 The speed up was over 24 times that of linear operations.
\end_layout

\begin_layout Paragraph
When implementing numerical analysis methods of any topic it is highly important
 to examine and cater to the platform that is being used.
 One must take into account if parallelization is possible, and where or
 not calculus based methods would be faster than algebraic approximations.
 In many cases it will not make a significant difference.
 In other cases where the data is large enough the exponential speed up
 would be much welcome.
\end_layout

\begin_layout Section
Appendix A
\end_layout

\end_body
\end_document
